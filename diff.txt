diff --git a/src/app/workspace/cmdinput/textareainput.tsx b/src/app/workspace/cmdinput/textareainput.tsx
index c5461a90..0d43a66c 100644
--- a/src/app/workspace/cmdinput/textareainput.tsx
+++ b/src/app/workspace/cmdinput/textareainput.tsx
@@ -131,165 +131,177 @@ class TextAreaInput extends React.Component<{ screen: Screen; onHeightChange: ()
         this.checkHeight(false);
         this.updateSP();
         let keybindManager = GlobalModel.keybindManager;
-        keybindManager.registerKeybinding("pane", "cmdinput", "any", (waveEvent) => {
-            return mobx.action(() => {
-                let inputRef = this.mainInputRef.current;
-                if (util.isModKeyPress(waveEvent)) {
-                    return false;
-                }
-                let model = GlobalModel;
-                let inputModel = model.inputModel;
-                let ctrlMod = waveEvent.control || waveEvent.cmd || waveEvent.shift;
-                let curLine = inputModel.getCurLine();
-
-                let lastTab = this.lastTab;
-                this.lastTab = keybindManager.checkKeyPressed(waveEvent, "cmdinput:autocomplete");
-                let lastHist = this.lastHistoryUpDown;
-                this.lastHistoryUpDown = false;
-
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:autocomplete")) {
-                    if (lastTab) {
-                        GlobalModel.submitCommand(
-                            "_compgen",
-                            null,
-                            [curLine],
-                            { comppos: String(curLine.length), compshow: "1", nohist: "1" },
-                            true
-                        );
-                    } else {
-                        GlobalModel.submitCommand(
-                            "_compgen",
-                            null,
-                            [curLine],
-                            { comppos: String(curLine.length), nohist: "1" },
-                            true
-                        );
+        if (GlobalModel.activeMainView.get() == "session") {
+            console.log("session");
+            keybindManager.registerKeybinding("pane", "cmdinput", "any", (waveEvent) => {
+                return mobx.action(() => {
+                    let inputRef = this.mainInputRef.current;
+                    if (util.isModKeyPress(waveEvent)) {
+                        return false;
                     }
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "generic:confirm")) {
-                    if (!ctrlMod) {
-                        if (GlobalModel.inputModel.isEmpty()) {
-                            let activeWindow = GlobalModel.getScreenLinesForActiveScreen();
-                            let activeScreen = GlobalModel.getActiveScreen();
-                            if (activeScreen != null && activeWindow != null && activeWindow.lines.length > 0) {
-                                activeScreen.setSelectedLine(0);
-                                GlobalCommandRunner.screenSelectLine("E");
-                            }
+                    let model = GlobalModel;
+                    let inputModel = model.inputModel;
+                    let ctrlMod = waveEvent.control || waveEvent.cmd || waveEvent.shift;
+                    let curLine = inputModel.getCurLine();
+
+                    let lastTab = this.lastTab;
+                    this.lastTab = keybindManager.checkKeyPressed(waveEvent, "cmdinput:autocomplete");
+                    let lastHist = this.lastHistoryUpDown;
+                    this.lastHistoryUpDown = false;
+
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:autocomplete")) {
+                        if (lastTab) {
+                            GlobalModel.submitCommand(
+                                "_compgen",
+                                null,
+                                [curLine],
+                                { comppos: String(curLine.length), compshow: "1", nohist: "1" },
+                                true
+                            );
                         } else {
-                            setTimeout(() => GlobalModel.inputModel.uiSubmitCommand(), 0);
+                            GlobalModel.submitCommand(
+                                "_compgen",
+                                null,
+                                [curLine],
+                                { comppos: String(curLine.length), nohist: "1" },
+                                true
+                            );
                         }
                         return true;
                     }
-                    inputRef.setRangeText("\n", inputRef.selectionStart, inputRef.selectionEnd, "end");
-                    GlobalModel.inputModel.setCurLine(inputRef.value);
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "generic:cancel")) {
-                    let inputModel = GlobalModel.inputModel;
-                    inputModel.toggleInfoMsg();
-                    console.log("hello?", inputModel.inputMode.get());
-                    if (inputModel.inputMode.get() != null) {
-                        inputModel.resetInputMode();
-                        console.log("hello? 2");
-                    }
-                    console.log("hello 3?");
-                    inputModel.closeAIAssistantChat(true);
-                    console.log("hello 4?");
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:expandInput")) {
-                    let inputModel = GlobalModel.inputModel;
-                    inputModel.toggleExpandInput();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:clearInput")) {
-                    inputModel.resetInput();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:cutLineLeftOfCursor")) {
-                    this.controlU();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:previousHistoryItem")) {
-                    this.controlP();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:nextHistoryItem")) {
-                    this.controlN();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:cutWordLeftOfCursor")) {
-                    this.controlW();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:paste")) {
-                    this.controlY();
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:openHistory")) {
-                    inputModel.openHistory();
-                    return true;
-                }
-                if (keybindManager.checkKeysPressed(waveEvent, ["generic:selectAbove", "generic:selectBelow"])) {
-                    if (!inputModel.isHistoryLoaded()) {
-                        if (keybindManager.checkKeyPressed(waveEvent, "generic:selectAbove")) {
-                            this.lastHistoryUpDown = true;
-                            inputModel.loadHistory(false, 1, "screen");
+                    if (keybindManager.checkKeyPressed(waveEvent, "generic:confirm")) {
+                        if (!ctrlMod) {
+                            if (GlobalModel.inputModel.isEmpty()) {
+                                let activeWindow = GlobalModel.getScreenLinesForActiveScreen();
+                                let activeScreen = GlobalModel.getActiveScreen();
+                                if (activeScreen != null && activeWindow != null && activeWindow.lines.length > 0) {
+                                    activeScreen.setSelectedLine(0);
+                                    GlobalCommandRunner.screenSelectLine("E");
+                                }
+                            } else {
+                                setTimeout(() => GlobalModel.inputModel.uiSubmitCommand(), 0);
+                            }
+                            return true;
                         }
+                        inputRef.setRangeText("\n", inputRef.selectionStart, inputRef.selectionEnd, "end");
+                        GlobalModel.inputModel.setCurLine(inputRef.value);
                         return true;
                     }
-                    // invisible history movement
-                    let linePos = this.getLinePos(inputRef);
-                    if (keybindManager.checkKeyPressed(waveEvent, "generic:selectAbove")) {
-                        if (!lastHist && linePos.linePos > 1) {
-                            // regular arrow
-                            return false;
+                    if (keybindManager.checkKeyPressed(waveEvent, "generic:cancel")) {
+                        let inputModel = GlobalModel.inputModel;
+                        inputModel.toggleInfoMsg();
+                        if (inputModel.inputMode.get() != null) {
+                            inputModel.resetInputMode();
                         }
-                        inputModel.moveHistorySelection(1);
-                        this.lastHistoryUpDown = true;
+                        inputModel.closeAIAssistantChat(true);
                         return true;
                     }
-                    if (keybindManager.checkKeyPressed(waveEvent, "generic:selectBelow")) {
-                        if (!lastHist && linePos.linePos < linePos.numLines) {
-                            // regular arrow
-                            return false;
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:expandInput")) {
+                        let inputModel = GlobalModel.inputModel;
+                        inputModel.toggleExpandInput();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:clearInput")) {
+                        inputModel.resetInput();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:cutLineLeftOfCursor")) {
+                        this.controlU();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:previousHistoryItem")) {
+                        this.controlP();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:nextHistoryItem")) {
+                        this.controlN();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:cutWordLeftOfCursor")) {
+                        this.controlW();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:paste")) {
+                        this.controlY();
+                        return true;
+                    }
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:openHistory")) {
+                        inputModel.openHistory();
+                        return true;
+                    }
+                    if (keybindManager.checkKeysPressed(waveEvent, ["generic:selectAbove", "generic:selectBelow"])) {
+                        if (!inputModel.isHistoryLoaded()) {
+                            if (keybindManager.checkKeyPressed(waveEvent, "generic:selectAbove")) {
+                                this.lastHistoryUpDown = true;
+                                inputModel.loadHistory(false, 1, "screen");
+                            }
+                            return true;
+                        }
+                        // invisible history movement
+                        let linePos = this.getLinePos(inputRef);
+                        if (keybindManager.checkKeyPressed(waveEvent, "generic:selectAbove")) {
+                            if (!lastHist && linePos.linePos > 1) {
+                                // regular arrow
+                                return false;
+                            }
+                            inputModel.moveHistorySelection(1);
+                            this.lastHistoryUpDown = true;
+                            return true;
+                        }
+                        if (keybindManager.checkKeyPressed(waveEvent, "generic:selectBelow")) {
+                            if (!lastHist && linePos.linePos < linePos.numLines) {
+                                // regular arrow
+                                return false;
+                            }
+                            inputModel.moveHistorySelection(-1);
+                            this.lastHistoryUpDown = true;
+                            return true;
+                        }
+                    }
+                    if (
+                        keybindManager.checkKeysPressed(waveEvent, [
+                            "generic:selectPageAbove",
+                            "generic:selectPageBelow",
+                        ])
+                    ) {
+                        let infoScroll = inputModel.hasScrollingInfoMsg();
+                        if (infoScroll) {
+                            let div = document.querySelector(".cmd-input-info");
+                            let amt = pageSize(div);
+                            scrollDiv(
+                                div,
+                                keybindManager.checkKeyPressed(waveEvent, "generic:selectPageAbove") ? -amt : amt
+                            );
                         }
-                        inputModel.moveHistorySelection(-1);
-                        this.lastHistoryUpDown = true;
                         return true;
                     }
-                }
-                if (
-                    keybindManager.checkKeysPressed(waveEvent, ["generic:selectPageAbove", "generic:selectPageBelow"])
-                ) {
-                    let infoScroll = inputModel.hasScrollingInfoMsg();
-                    if (infoScroll) {
-                        let div = document.querySelector(".cmd-input-info");
-                        let amt = pageSize(div);
-                        scrollDiv(
-                            div,
-                            keybindManager.checkKeyPressed(waveEvent, "generic:selectPageAbove") ? -amt : amt
-                        );
+                    if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:openAIChat")) {
+                        inputModel.openAIAssistantChat();
+                        return true;
                     }
-                    return true;
-                }
-                if (keybindManager.checkKeyPressed(waveEvent, "cmdinput:openAIChat")) {
-                    inputModel.openAIAssistantChat();
-                    return true;
-                }
-                // console.log(e.code, e.keyCode, e.key, event.which, ctrlMod, e);
-                return false;
-            })();
-        });
+                    // console.log(e.code, e.keyCode, e.key, event.which, ctrlMod, e);
+                    return false;
+                })();
+            });
+        } else {
+            console.log("not session");
+            keybindManager.unregisterDomain("cmdinput");
+        }
     }
 
     componentWillUnmount(): void {
+        console.log("component unmounted??");
         let keybindManager = GlobalModel.keybindManager;
         keybindManager.unregisterDomain("cmdinput");
     }
 
     componentDidUpdate() {
+        console.log("component update");
+        if (GlobalModel.activeMainView.get() != "session") {
+            console.log("unregistering");
+            let keybindManager = GlobalModel.keybindManager;
+            keybindManager.unregisterDomain("cmdinput");
+        }
         let activeScreen = GlobalModel.getActiveScreen();
         if (activeScreen != null) {
             let focusType = activeScreen.focusType.get();
